<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>2048 en JavaScript</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <!-- Lien vers le manifest -->
  <link rel="manifest" href="manifest.json">
  <style>
    body {
      font-family: 'Arial', sans-serif;
      text-align: center;
      background-color: #faf8ef;
      margin: 0;
      padding: 0;
    }

    h1 {
      margin-top: 20px;
    }

    #game-container-wrapper {
      position: relative;
      width: 90vw;
      max-width: 500px;
      margin: 20px auto;
      padding-bottom: 70px;
    }

    #game-container {
      width: 100%;
      height: 100%;
      background-color: #bbada0;
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 10px;
      border-radius: 10px;
      padding: 10px;
      box-sizing: border-box;
      margin: 0 auto;
    }

    .tile {
      background-color: #cdc1b4;
      font-size: calc(2vw + 2vh);
      color: #776e65;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 5px;
      transition: all 0.2s ease;
    }

    .tile.new {
      animation: appear 0.2s ease;
    }

    @keyframes appear {
      from {
        transform: scale(0);
      }
      to {
        transform: scale(1);
      }
    }

    /* Styles pour les boutons de contrôle */
    #controls {
      margin-top: 20px;
    }

    #controls button {
      background-color: #8f7a66;
      color: #f9f6f2;
      font-size: 18px;
      padding: 10px 20px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }

    #controls button:hover {
      background-color: #a67c52;
    }
  </style>
</head>
<body>
  <h1>2048</h1>
  <div id="game-container-wrapper">
    <div id="game-container">
      <!-- La grille du jeu sera générée ici -->
    </div>
  </div>

  <!-- Boutons de contrôle -->
  <div id="controls">
    <button id="undo-button">Annuler</button>
    <button id="next-four-button">Prochaine tuile : 4</button>
  </div>

  <script>
    const gridSize = 4;
    let grid = [];
    let previousGrid = [];
    let score = 0;
    let previousScore = 0;
    let nextTileIsFour = false;

    // Création d'une grille vide
    function createEmptyGrid() {
      grid = [];
      for (let i = 0; i < gridSize; i++) {
        grid[i] = [];
        for (let j = 0; j < gridSize; j++) {
          grid[i][j] = 0;
        }
      }
    }

    // Copier la grille actuelle
    function copyGrid(grid) {
      let newGrid = [];
      for (let i = 0; i < gridSize; i++) {
        newGrid[i] = grid[i].slice();
      }
      return newGrid;
    }

    // Sauvegarder l'état actuel
    function saveState() {
      previousGrid = copyGrid(grid);
      previousScore = score;
    }

    // Restaurer l'état précédent
    function undo() {
      if (previousGrid.length > 0) {
        grid = copyGrid(previousGrid);
        score = previousScore;
        updateGrid();
      } else {
        alert("Impossible d'annuler !");
      }
    }

    // Ajout d'une nouvelle tuile
    function addNewTile() {
      let options = [];
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] === 0) {
            options.push({ x: i, y: j });
          }
        }
      }
      if (options.length > 0) {
        let spot = options[Math.floor(Math.random() * options.length)];
        grid[spot.x][spot.y] = nextTileIsFour ? 4 : (Math.random() < 0.9 ? 2 : 4);
        nextTileIsFour = false;
      }
    }

    // Mise à jour de l'affichage de la grille
    function updateGrid() {
      const gameContainer = document.getElementById('game-container');
      gameContainer.innerHTML = '';
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const tile = document.createElement('div');
          tile.classList.add('tile');
          if (grid[i][j] !== 0) {
            tile.textContent = grid[i][j];
            tile.style.backgroundColor = getTileColor(grid[i][j]);
            tile.classList.add('new');
          } else {
            tile.textContent = '';
            tile.style.backgroundColor = '#cdc1b4';
          }
          gameContainer.appendChild(tile);
        }
      }
    }

    // Couleurs des tuiles
    function getTileColor(value) {
      const colors = {
        2: '#eee4da',
        4: '#ede0c8',
        8: '#f2b179',
        16: '#f59563',
        32: '#f67c5f',
        64: '#f65e3b',
        128: '#edcf72',
        256: '#edcc61',
        512: '#edc850',
        1024: '#edc53f',
        2048: '#edc22e',
      };
      return colors[value] || '#3c3a32';
    }

    // Écoute des touches du clavier
    document.addEventListener('keydown', handleKeyPress);

    function handleKeyPress(event) {
      let moved = false;
      saveState();
      switch (event.key) {
        case 'ArrowUp':
          moved = slideUp();
          break;
        case 'ArrowDown':
          moved = slideDown();
          break;
        case 'ArrowLeft':
          moved = slideLeft();
          break;
        case 'ArrowRight':
          moved = slideRight();
          break;
      }
      if (moved) {
        addNewTile();
        updateGrid();
        checkGameOver();
      }
    }

    // Gestion des gestes tactiles
    let touchStartX = null;
    let touchStartY = null;

    document.addEventListener('touchstart', function(event) {
      touchStartX = event.changedTouches[0].screenX;
      touchStartY = event.changedTouches[0].screenY;
    }, false);

    document.addEventListener('touchend', function(event) {
      if (!touchStartX || !touchStartY) {
        return;
      }
      let touchEndX = event.changedTouches[0].screenX;
      let touchEndY = event.changedTouches[0].screenY;

      let deltaX = touchEndX - touchStartX;
      let deltaY = touchEndY - touchStartY;

      if (Math.abs(deltaX) > Math.abs(deltaY)) {
        // Mouvement horizontal
        if (deltaX > 30) {
          simulateKeyPress('ArrowRight');
        } else if (deltaX < -30) {
          simulateKeyPress('ArrowLeft');
        }
      } else {
        // Mouvement vertical
        if (deltaY > 30) {
          simulateKeyPress('ArrowDown');
        } else if (deltaY < -30) {
          simulateKeyPress('ArrowUp');
        }
      }
      touchStartX = null;
      touchStartY = null;
    }, false);

    // Simulation de la pression des touches
    function simulateKeyPress(key) {
      handleKeyPress({ key: key });
    }

    // Écouteurs pour les boutons
    document.getElementById('undo-button').addEventListener('click', function() {
      undo();
    });

    document.getElementById('next-four-button').addEventListener('click', function() {
      nextTileIsFour = true;
    });

    // Fonctions de glissement des tuiles
    function slide(row) {
      let arr = row.filter(val => val);
      for (let i = 0; i < arr.length - 1; i++) {
        if (arr[i] === arr[i + 1]) {
          arr[i] *= 2;
          score += arr[i];
          playSound(arr[i]);
          arr[i + 1] = 0;
        }
      }
      arr = arr.filter(val => val);
      while (arr.length < gridSize) {
        arr.push(0);
      }
      return arr;
    }

    function slideLeft() {
      let moved = false;
      for (let i = 0; i < gridSize; i++) {
        let originalRow = grid[i].slice();
        let newRow = slide(grid[i]);
        grid[i] = newRow;
        if (!arraysEqual(originalRow, newRow)) {
          moved = true;
        }
      }
      return moved;
    }

    function slideRight() {
      let moved = false;
      for (let i = 0; i < gridSize; i++) {
        let originalRow = grid[i].slice();
        let reversedRow = grid[i].slice().reverse();
        let newRow = slide(reversedRow);
        grid[i] = newRow.reverse();
        if (!arraysEqual(originalRow, grid[i])) {
          moved = true;
        }
      }
      return moved;
    }

    function slideUp() {
      let moved = false;
      for (let j = 0; j < gridSize; j++) {
        let col = [];
        for (let i = 0; i < gridSize; i++) {
          col.push(grid[i][j]);
        }
        let originalCol = col.slice();
        let newCol = slide(col);
        for (let i = 0; i < gridSize; i++) {
          grid[i][j] = newCol[i];
        }
        if (!arraysEqual(originalCol, newCol)) {
          moved = true;
        }
      }
      return moved;
    }

    function slideDown() {
      let moved = false;
      for (let j = 0; j < gridSize; j++) {
        let col = [];
        for (let i = 0; i < gridSize; i++) {
          col.push(grid[i][j]);
        }
        let originalCol = col.slice();
        let reversedCol = col.slice().reverse();
        let newCol = slide(reversedCol);
        newCol = newCol.reverse();
        for (let i = 0; i < gridSize; i++) {
          grid[i][j] = newCol[i];
        }
        if (!arraysEqual(originalCol, newCol)) {
          moved = true;
        }
      }
      return moved;
    }

    function arraysEqual(a, b) {
      return JSON.stringify(a) === JSON.stringify(b);
    }

    // Vérification de la fin du jeu
    function checkGameOver() {
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] === 0) {
            return;
          }
          if (j !== gridSize - 1 && grid[i][j] === grid[i][j + 1]) {
            return;
          }
          if (i !== gridSize - 1 && grid[i][j] === grid[i + 1][j]) {
            return;
          }
        }
      }
      alert('Game Over!');
    }

    // Vérification de la victoire
    function checkWin() {
      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] === 2048) {
            alert('Vous avez gagné !');
          }
        }
      }
    }

    // Fonction pour jouer un son en fonction de la valeur fusionnée
    function playSound(value) {
      const context = new (window.AudioContext || window.webkitAudioContext)();
      const oscillator = context.createOscillator();
      const gainNode = context.createGain();

      // Définir la fréquence en fonction de la valeur
      let frequency = 200 + (Math.log2(value) * 100);
      oscillator.frequency.value = frequency;

      oscillator.type = 'sine';
      oscillator.connect(gainNode);
      gainNode.connect(context.destination);

      oscillator.start();
      gainNode.gain.exponentialRampToValueAtTime(0.0001, context.currentTime + 0.2);
      oscillator.stop(context.currentTime + 0.2);
    }

    // Initialisation du jeu
    function init() {
      createEmptyGrid();
      addNewTile();
      addNewTile();
      updateGrid();
    }

    init();

    // Enregistrement du service worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('service-worker.js')
        .then(function(registration) {
          console.log('Service Worker enregistré avec succès:', registration);
        })
        .catch(function(error) {
          console.log('Échec de l\'enregistrement du Service Worker:', error);
        });
    }
  </script>
</body>
</html>